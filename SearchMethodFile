public virtual async Task<IPagedList<Product>> SearchProductsAsync( int pageIndex = 0, int pageSize = int.MaxValue, IList<int> categoryIds = null, IList<int> manufacturerIds = null, int storeId = 0, int vendorId = 0, int warehouseId = 0, ProductType? productType = null, bool visibleIndividuallyOnly = true, bool excludeFeaturedProducts = false, decimal? priceMin = null, decimal? priceMax = null, int productTagId = 0, string keywords = null, bool searchDescriptions = true, bool searchManufacturerPartNumber = true, bool searchSku = true, bool searchProductTags = true, int languageId = 0, IList<SpecificationAttributeOption> filteredSpecOptions = null, ProductSortingEnum orderBy = ProductSortingEnum.Position, bool showHidden = false, bool? overridePublished = true, bool hasGift = false, string name = "", string brands = "", bool isAvailable = false, int priceStatusId = 0, int quantityStatusId = 0, bool hasparent = false, int disableBuyButton = 0, bool isCombinations = false) { //some databases don't support int.MaxValue if (pageSize == int.MaxValue) pageSize = int.MaxValue - 1; var productsQuery = _productRepository.Table; var giftsQuery = _giftProductRepository.Table; var manufacturesQuery = _productManufacturerRepository.Table; // if exist in only gift products if (hasGift) { productsQuery = from p in productsQuery join gift in giftsQuery on p.Id equals gift.ProductId1 select p; productsQuery = productsQuery.GroupBy(item => item.Id) .SelectMany(x => x.Take(1)); } if (!string.IsNullOrEmpty(name)) { productsQuery = from p in productsQuery where p.Name.Contains(name) select p; productsQuery = productsQuery.GroupBy(item => item.Id) .SelectMany(x => x.Take(1)); } if (!string.IsNullOrEmpty(brands)) { var brandArray = brands.Split(",").ToList(); productsQuery = from p in productsQuery join manufacture in manufacturesQuery on p.Id equals manufacture.ProductId where brandArray.Contains(manufacture.ManufacturerId.ToString()) select p; productsQuery = productsQuery.GroupBy(item => item.Id) .SelectMany(x => x.Take(1)); } if (overridePublished.HasValue) { productsQuery = overridePublished.Value ? productsQuery.Where(p => p.Published) : productsQuery.Where(p => !p.Published); } //if (!showHidden) //{ // productsQuery = productsQuery.Where(p => p.Published); //} //else if (overridePublished.HasValue) // productsQuery = productsQuery.Where(p => p.Published == overridePublished.Value); //apply store mapping constraints productsQuery = await _storeMappingService.ApplyStoreMapping(productsQuery, storeId); //apply ACL constraints var customer = await _workContext.GetCurrentCustomerAsync(); productsQuery = await _aclService.ApplyAcl(productsQuery, customer); if (disableBuyButton > 0) { productsQuery = productsQuery .Where(p => p.DisableBuyButton == (disableBuyButton == 1 ? true : false)); } productsQuery = from p in productsQuery where !p.Deleted && (vendorId == 0 || p.VendorId == vendorId) && ( warehouseId == 0 || ( !p.UseMultipleWarehouses ? p.WarehouseId == warehouseId : _productWarehouseInventoryRepository.Table.Any(pwi => pwi.Id == warehouseId && pwi.ProductId == p.Id) ) ) && (productType == null || p.ProductTypeId == (int)productType) && (showHidden == false || LinqToDB.Sql.Between(DateTime.UtcNow, p.AvailableStartDateTimeUtc ?? DateTime.MinValue, p.AvailableEndDateTimeUtc ?? DateTime.MaxValue)) select p; if (visibleIndividuallyOnly) { productsQuery = from p in productsQuery where p.VisibleIndividually select p; } var pName = name == "" ? keywords : name; if (!string.IsNullOrEmpty(pName)) { productsQuery = from p in productsQuery where p.Gtin.Contains(pName) || p.ManufacturerPartNumber.Contains(pName) || p.Sku.Contains(pName) || p.Name.Contains(pName) select p; } if (!string.IsNullOrEmpty(keywords)) { //var langs = await _languageService.GetAllLanguagesAsync(showHidden: true); //Set a flag which will to points need to search in localized properties. If showHidden doesn't set to true should be at least two published languages. var searchLocalizedValue = true;//languageId > 0 && langs.Count() >= 2; IQueryable<int> productsByKeywords; searchDescriptions = false; productsByKeywords = from p in _productRepository.Table where p.Name.Contains(keywords) || (searchDescriptions && (p.ShortDescription.Contains(keywords) || p.FullDescription.Contains(keywords))) || (searchManufacturerPartNumber && p.ManufacturerPartNumber == keywords) || (searchSku && p.Sku.Contains(keywords)) || p.Gtin.Contains(keywords) select p.Id; //search by SKU for ProductAttributeCombination if (searchSku) { productsByKeywords = productsByKeywords.Union( from pac in _productAttributeCombinationRepository.Table where pac.Sku == keywords select pac.ProductId); } searchProductTags = true; if (searchProductTags) { productsByKeywords = productsByKeywords.Union( from pptm in _productTagMappingRepository.Table join pt in _productTagRepository.Table on pptm.ProductTagId equals pt.Id where pt.Name == keywords select pptm.ProductId ); if (searchLocalizedValue) { productsByKeywords = productsByKeywords.Union( from pptm in _productTagMappingRepository.Table join lp in _localizedPropertyRepository.Table on pptm.ProductTagId equals lp.EntityId where lp.LocaleKeyGroup == nameof(ProductTag) && lp.LocaleKey == nameof(ProductTag.Name) && lp.LocaleValue.Contains(keywords) select lp.EntityId); } } if (searchLocalizedValue) { productsByKeywords = productsByKeywords.Union( from lp in _localizedPropertyRepository.Table let checkName = lp.LocaleKey == nameof(Product.Name) && lp.LocaleValue.Contains(keywords) let checkShortDesc = searchDescriptions && lp.LocaleKey == nameof(Product.ShortDescription) && lp.LocaleValue.Contains(keywords) let checkProductTags = searchProductTags && lp.LocaleKeyGroup == nameof(ProductTag) && lp.LocaleKey == nameof(ProductTag.Name) && lp.LocaleValue.Contains(keywords) where (lp.LocaleKeyGroup == nameof(Product)) && (checkName || checkShortDesc) || checkProductTags select lp.EntityId); } var productsBykeywordentity = await _productRepository.GetByIdsAsync(productsByKeywords.Distinct().ToArray()); productsQuery = productsBykeywordentity.AsQueryable().Union(productsQuery.Where(c => !c.Deleted)); } if (productTagId > 0) { productsQuery = from p in productsQuery join ptm in _productTagMappingRepository.Table on p.Id equals ptm.ProductId where ptm.ProductTagId == productTagId select p; } if (categoryIds is not null) { if (categoryIds.Contains(0)) categoryIds.Remove(0); if (categoryIds.Any()) { var productCategoryQuery = from pc in _productCategoryRepository.Table where (!excludeFeaturedProducts || !pc.IsFeaturedProduct) && categoryIds.Contains(pc.CategoryId) select pc; productsQuery = from p in productsQuery join cat in productCategoryQuery on p.Id equals cat.ProductId select p; } } if (manufacturerIds is not null) { if (manufacturerIds.Contains(0)) manufacturerIds.Remove(0); if (manufacturerIds.Any()) { var productManufacturerQuery = from pm in _productManufacturerRepository.Table where (!excludeFeaturedProducts || !pm.IsFeaturedProduct) && manufacturerIds.Contains(pm.ManufacturerId) select pm; productsQuery = from p in productsQuery where productManufacturerQuery.Any(pm => pm.ProductId == p.Id) select p; } } if (!hasparent) { productsQuery = from p in productsQuery where p.ParentGroupedProductId == 0 select p; } if (filteredSpecOptions?.Count > 0) { var specificationAttributeIds = filteredSpecOptions .Select(sao => sao.SpecificationAttributeId) .Distinct(); foreach (var specificationAttributeId in specificationAttributeIds) { var optionIdsBySpecificationAttribute = filteredSpecOptions .Where(o => o.SpecificationAttributeId == specificationAttributeId) .Select(o => o.Id); var productSpecificationQuery = from psa in _productSpecificationAttributeRepository.Table where (!psa.AllowFiltering.HasValue ? false : psa.AllowFiltering.Value) == true && optionIdsBySpecificationAttribute.Contains(psa.SpecificationAttributeOptionId) select psa; productsQuery = from p in productsQuery where productSpecificationQuery.Any(pc => pc.ProductId == p.Id) select p; } } if (isCombinations) { name = string.IsNullOrEmpty(name) ? keywords : name; var combinations = await SearchCombinationsAsync(name: name, categoryIds: categoryIds, includeSearch: isCombinations, priceStatusId: priceStatusId, quantityStatusId: quantityStatusId); var productIds = combinations.Select(x => x.ProductId).ToArray(); var combinationProducts = _productRepository.Table .Where(x => productIds.Contains(x.Id)); productsQuery = productsQuery.Concat(combinationProducts); } //productsQuery = productsQuery.OrderByQuantity(orderBy); //productsQuery = productsQuery.OrderByDescending(c => c.StockQuantity); //return await productsQuery.ToPagedListAsync(pageIndex, pageSize); productsQuery = productsQuery.Where(c => !c.Deleted); var listedProductQuery = new List<Product>(); if (isCombinations) { var filteredProductQuery = await productsQuery.Where(pq => pq.ManageInventoryMethodId == 2).ToListAsync(); listedProductQuery = filteredProductQuery; } else { var filteredProductQuery = await productsQuery.ToListAsync(); listedProductQuery = filteredProductQuery; } var notAvailableQuery = new List<Product>(); var availableQuery = new List<Product>(); foreach (var item in listedProductQuery) { var combination = await _productAttributeService.GetAllProductAttributeCombinationsAsync(item.Id); if (item.DisableBuyButton) { if (!notAvailableQuery.Select(c => c.Id).Contains(item.Id) && !availableQuery.Select(c => c.Id).Contains(item.Id)) { notAvailableQuery.Add(item); continue; } } if (combination.Any()) { if (isCombinations && (priceStatusId > 0 || quantityStatusId > 0)) { if (priceStatusId == 1 && quantityStatusId == 1) { combination = combination.Where(c => (c.OverriddenPrice > 0 && c.OverriddenPrice != null) && (c.StockQuantity > 0)).ToList(); } if (priceStatusId == 2 && quantityStatusId == 2) combination = combination.Where(c => (c.OverriddenPrice == 0 && c.OverriddenPrice == null) && (c.StockQuantity == 0)).ToList(); if (quantityStatusId == 1 && priceStatusId == 2) combination = combination.Where(c => (c.StockQuantity > 0) && (c.OverriddenPrice == 0 && c.OverriddenPrice == null)).ToList(); if (quantityStatusId == 2 && priceStatusId == 1) combination = combination.Where(c => (c.StockQuantity == 0) && c.OverriddenPrice > 0 && c.OverriddenPrice != null).ToList(); var targetCombination = combination.OrderBy(c => c.OverriddenPrice).FirstOrDefault(); if (combination.Any()) { item.Price = targetCombination.OverriddenPrice.Value; item.StockQuantity = targetCombination.StockQuantity; } } else { combination = combination.Where(c => c.OverriddenPrice > 0 && c.StockQuantity > 0).ToList(); if (combination.Any()) { var targetCombination = combination.OrderBy(c => c.OverriddenPrice).FirstOrDefault(); item.Price = targetCombination.OverriddenPrice.Value; item.StockQuantity = targetCombination.StockQuantity; } } } if (item.Price > 0 && item.StockQuantity > 0) { if (!notAvailableQuery.Select(c => c.Id).Contains(item.Id) && !availableQuery.Select(c => c.Id).Contains(item.Id)) { availableQuery.Add(item); } } else { if (!notAvailableQuery.Select(c => c.Id).Contains(item.Id) && !availableQuery.Select(c => c.Id).Contains(item.Id)) { notAvailableQuery.Add(item); continue; } } } var result = availableQuery.AsQueryable(); result = from p in result where (priceMin == null || p.Price >= priceMin) && (priceMax == null || p.Price <= priceMax) select p; result = result.OrderBy(orderBy); if (quantityStatusId > 0 || priceStatusId > 0) { var ids = result.Select(x => x.Id).ToArray(); var comb = _productAttributeCombinationRepository.Table .Where(x => ids.Contains(x.ProductId)) .GroupBy(g => g.ProductId) .Select(xx => new { ProductId = xx.FirstOrDefault().ProductId, StockQuantity = xx.Sum(xx => xx.StockQuantity), Price = xx.Sum(xx => xx.OverriddenPrice) }); if (priceStatusId == 2) { var comb1 = comb.Where(x => x.StockQuantity > 0); var comb1Ids1 = comb1.Select(x => x.ProductId).ToArray(); var product1 = result.Where(x => x.StockQuantity > 0 || comb1Ids1.Contains(x.Id)); var product1Ids = product1.Select(x => x.Id).ToArray(); result = result.Where(x => x.StockQuantity > 0 && (!comb1Ids1.Contains(x.Id) && !product1Ids.Contains(x.Id))); result = result.Concat(product1); } if (quantityStatusId == 2) { var comb2 = comb.Where(x => x.StockQuantity == 0); var comb1Ids2 = comb2.Select(x => x.ProductId).ToArray(); var product2 = result.Where(x => x.StockQuantity == 0 && comb1Ids2.Contains(x.Id)); var product1Ids = product2.Select(x => x.Id).ToArray(); result = result.Where(x => x.StockQuantity == 0 && !comb1Ids2.Contains(x.Id)); result = result.Concat(product2); } if (priceStatusId == 1) { var comb1 = comb.Where(x => x.Price > 0); var comb1Ids1 = comb1.Select(x => x.ProductId).ToArray(); var product1 = result.Where(x => x.Price > 0 || comb1Ids1.Contains(x.Id)); var product1Ids = product1.Select(x => x.Id).ToArray(); result = result.Where(x => x.Price > 0 && (!comb1Ids1.Contains(x.Id) && !product1Ids.Contains(x.Id))); result = result.Concat(product1); } if (priceStatusId == 2) { var comb2 = comb.Where(x => x.Price == 0); var comb1Ids2 = comb2.Select(x => x.ProductId).ToArray(); var product2 = result.Where(x => x.StockQuantity == 0 && comb1Ids2.Contains(x.Id)); var product1Ids = product2.Select(x => x.Id).ToArray(); result = result.Where(x => x.StockQuantity == 0 && !comb1Ids2.Contains(x.Id)); result = result.Concat(product2); } } //var available = productsQuery.Where(c => // c.StockQuantity > 0 && c.Published && c.Price > 0 && !c.DisableBuyButton); //var orderedavailable = available.OrderBy(orderBy); //var notAvailable = productsQuery.Where(c => !available.Contains(c)); //var result = orderedavailable.Concat(notAvailable); var available = result.OrderBy(orderBy); var finalResult = isAvailable ? available.AsQueryable() : available.Concat(notAvailableQuery.AsQueryable()); if (!isCombinations) { if (priceStatusId == 1) { finalResult = from p in finalResult where p.Price > 0 select p; } if (priceStatusId == 2) { finalResult = from p in finalResult where p.Price == 0 select p; } if (quantityStatusId > 0) { var ids = finalResult.Select(x => x.Id).ToArray(); var comb = _productAttributeCombinationRepository.Table .Where(x => ids.Contains(x.ProductId)) .GroupBy(g => g.ProductId) .Select(xx => new { ProductId = xx.FirstOrDefault().ProductId, StockQuantity = xx.Sum(xx => xx.StockQuantity) }); var combIds = comb.Select(x => x.ProductId).ToArray(); if (quantityStatusId == 1) { var comb1 = comb.Where(x => x.StockQuantity > 0); var comb1Ids1 = comb1.Select(x => x.ProductId).ToArray(); var product1 = finalResult.Where(x => x.StockQuantity > 0 || comb1Ids1.Contains(x.Id)); var product1Ids = product1.Select(x => x.Id).ToArray(); finalResult = finalResult.Where(x => x.StockQuantity > 0 && (!comb1Ids1.Contains(x.Id) && !product1Ids.Contains(x.Id))); finalResult = finalResult.Concat(product1); } if (quantityStatusId == 2) { var comb2 = comb.Where(x => x.StockQuantity == 0); var comb1Ids2 = comb2.Select(x => x.ProductId).ToArray(); var product2 = finalResult.Where(x => x.StockQuantity == 0 && comb1Ids2.Contains(x.Id)); var product1Ids = product2.Select(x => x.Id).ToArray(); finalResult = finalResult.Where(x => x.StockQuantity == 0 && !comb1Ids2.Contains(x.Id)); finalResult = finalResult.Concat(product2); } } } //we have to set fake order to prevent order by changing in skip method inside toapgedlist. return await finalResult.ToPagedListAsync(pageIndex, pageSize); }
